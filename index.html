<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV to JSON Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <h1>Dreamborn => Lorcana app converter</h1>
    <p>Upload your Dreamborn collection (export.csv) to generate a file that can be used by Lorcana's official app.</p>
    <h3>Notes</h3>    
    <p>I am not affiliated with Dreamborn, Ravensburger or Disney. Trademarks belong to their respective owners. This tool is provided as-is. I am not responsible for any issues that may arise from its use. Use at your own risk.<br>
    <br>This tool runs locally in your browser, no data is submitted to any server.
    <h3>Current limitations</h3>
    <ul><li>I have no iOS devices at hand. I cannot say if importing the created file will work or not.</li>
        <li>Iago - Out of Reach (D23 promo) cannot be imported, this card does not show in the app for me.</li>
        <li>Mickey Mouse - True Friend (promo) cannot be imported, this card does not show in the app for me.</li>
    </ul>
    </p>
    <h3>Bug reports</h3>
    <p>If you encounter any bugs, drop a mail at lorcanaappimporter@posteo.de. Please be very specific with the cards you wanted to import and what happened you think was wrong. I will need your export.csv from Dreamborn (remove stuff you do not want to show) and the text from your terminal (if any).</p>
    <h3>License terms</h3>
    <p>
        Copyright (c) 2025 Maik Himstedt<br>
        This tool is licensed under the <a href="https://opensource.org/license/bsd-2-clause" target="_blank">BSD 2-Clause License</a>.<br>
        It uses PapaParse Copyright (c) 2015 Matthew Holt. PapaParse is licensed under the <a href="https://opensource.org/license/mit" target="_blank">MIT license</a>.<br>
    </p>    
    <h3>Usage</h3>
    <p><ol>
        <li>Export your collection at Dreamborn. You will get a file named export.csv</li>
        <li>Upload the export.csv from step 1 unaltered here and hit the "Click to convert" button.</li>
        <li>Optional but highly recommended: backup you previous userdata.json from your phone located at Android\data\com.ravensburger.disney.lorcana\files</li>
        <li>Fully close down the Lorcana app on your phone.</li>
        <li>Replace the userdata.json on your phone (s. step 3) with the file generated by the script.</li>
        <li>Start Lorcana app and see your personal collection.</li>
      </ol>
    </p>


    <form id="csvForm">
        <label for="exportFile">Select your export.csv:</label><br><br>
        <input type="file" id="exportFile" accept=".csv" required><br><br>

        <button type="submit">Click to convert</button>
        <h3>Log messages</h3>
    </form>
    <pre id="logMessages"></pre>
        
    <script>
        function logMessage(message) {
            const logElement = document.getElementById('logMessages');
            logElement.textContent += message + '\n';
        }

        document.getElementById('csvForm').addEventListener('submit', async (event) => {
            event.preventDefault();

            const exportFileInput = document.getElementById('exportFile');
            const exportFile = document.getElementById('exportFile').files[0];

            if (!exportFile) {
                alert('Please upload the export.csv file.');
                return;
            }

            try {
                const exportData = await parseCsvFile(exportFile);
                const mappingData = await fetchMappingFile();

                const jsonOutput = processCsvData(exportData, mappingData);

                // Offer the JSON as a downloadable file
                const blob = new Blob([JSON.stringify(jsonOutput, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'userdata.json';
                a.click();
                URL.revokeObjectURL(url);
                // De-select the uploaded file
                exportFileInput.value = '';
            } catch (error) {
                logMessage('An error occurred: ' + error.message);
                alert('An error occurred while processing the files. Check the log messages for details.');
            }
        });

        function parseCsvFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    Papa.parse(event.target.result, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => resolve(results.data),
                        error: (error) => reject(error),
                    });
                };
                reader.onerror = (error) => reject(error);
                reader.readAsText(file);
            });
        }

        async function fetchMappingFile() {
            const response = await fetch('mapping.csv');
            if (!response.ok) {
                throw new Error('Failed to load mapping.csv');
            }
            const text = await response.text();
            return new Promise((resolve, reject) => {
                Papa.parse(text, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        // Validate the structure of the parsed data
                        if (!results.data.every(row => row.Set && row["Card Number"] && row.ID)) {
                            reject(new Error('Invalid mapping.csv structure.'));
                        } else {
                            resolve(results.data);
                        }
                    },
                    error: (error) => reject(error),
                });
            });
        }

        function processCsvData(exportData, mappingData) {
            // Create a mapping hash for quick lookups
            const mappingHash = {};
            mappingData.forEach(row => {
                const key = `${row.Set}-${row["Card Number"]}`;
                mappingHash[key] = row.ID;
            });

            // Initialize the template object
            const h = {
                Wishlist: [],
                OwnedCardQuantitiesV2: [],
                Decks: [],
                TutorialChapterStates: {
                    WhatIsLorcana: "Completed",
                    SettingUp: "Completed",
                    PowerOfInk: "Completed",
                    StartPlaying: "Completed",
                    UsingCards: "Completed"
                },
                DisabledMaxSameCardsPerDeckPopup: false,
                PlayedIllumineerQuests: ["DeepTrouble"]
            };

            // Process each row in the export data
            exportData.forEach(row => {
                const key = `${row.Set.replace(/^0+/, '')}-${row["Card Number"].replace(/^0+/, '')}`;
                const id = mappingHash[key];

                if (!id) {
                    logMessage(`ID not found for Set: ${row.Set}, Number: ${row["Card Number"]}, card not imported.`);
                    return;
                }

                // Add Normal cards
                if (parseInt(row.Normal, 10) > 0) {
                    h.OwnedCardQuantitiesV2.push({
                        Id: id,
                        Type: "Regular",
                        Quantity: parseInt(row.Normal, 10)
                    });
                }

                // Add Foil cards
                if (parseInt(row.Foil, 10) > 0) {
                    h.OwnedCardQuantitiesV2.push({
                        Id: id,
                        Type: "Foiled",
                        Quantity: parseInt(row.Foil, 10)
                    });
                }
            });

            logMessage('Processing completed successfully.');
            return h;
        }
    </script>
</body>
</html>